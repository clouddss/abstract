import { prisma } from '../../database/client';\nimport { Prisma } from '@prisma/client';\n\n/**\n * Performance monitoring service for database operations\n */\nexport class PerformanceMonitoringService {\n  \n  /**\n   * Check database performance metrics\n   */\n  static async getDatabaseMetrics() {\n    try {\n      // Get table sizes\n      const tableSizes = await prisma.$queryRaw<Array<{\n        table_name: string;\n        size_bytes: bigint;\n        size_pretty: string;\n        row_count: bigint;\n      }>>`\n        SELECT \n          schemaname || '.' || tablename as table_name,\n          pg_total_relation_size(schemaname||'.'||tablename) as size_bytes,\n          pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as size_pretty,\n          n_tup_ins + n_tup_upd + n_tup_del as row_count\n        FROM pg_tables \n        JOIN pg_stat_user_tables ON pg_tables.tablename = pg_stat_user_tables.relname\n        WHERE schemaname = 'public'\n        ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC\n      `;\n\n      // Get index usage statistics\n      const indexUsage = await prisma.$queryRaw<Array<{\n        schemaname: string;\n        tablename: string;\n        indexname: string;\n        idx_scan: bigint;\n        idx_tup_read: bigint;\n        idx_tup_fetch: bigint;\n      }>>`\n        SELECT \n          schemaname,\n          tablename,\n          indexname,\n          idx_scan,\n          idx_tup_read,\n          idx_tup_fetch\n        FROM pg_stat_user_indexes \n        WHERE schemaname = 'public'\n        ORDER BY idx_scan DESC\n        LIMIT 20\n      `;\n\n      // Get slow queries (if pg_stat_statements is available)\n      let slowQueries = [];\n      try {\n        slowQueries = await prisma.$queryRaw<Array<{\n          query: string;\n          calls: bigint;\n          total_time: number;\n          mean_time: number;\n          rows: bigint;\n        }>>`\n          SELECT \n            query,\n            calls,\n            total_time,\n            mean_time,\n            rows\n          FROM pg_stat_statements \n          WHERE query LIKE '%trades%' OR query LIKE '%holders%' OR query LIKE '%tokens%'\n          ORDER BY mean_time DESC\n          LIMIT 10\n        `;\n      } catch {\n        // pg_stat_statements not available\n      }\n\n      return {\n        tableSizes,\n        indexUsage,\n        slowQueries,\n        timestamp: new Date()\n      };\n    } catch (error) {\n      console.error('Error getting database metrics:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Monitor volume calculation performance\n   */\n  static async benchmarkVolumeCalculations(tokenAddress: string) {\n    const startTime = Date.now();\n    \n    try {\n      // Test different volume calculation methods\n      const results = {\n        direct_query: await this.benchmarkDirectQuery(tokenAddress),\n        aggregated_query: await this.benchmarkAggregatedQuery(tokenAddress),\n        materialized_view: await this.benchmarkMaterializedView(tokenAddress)\n      };\n\n      return {\n        results,\n        totalTime: Date.now() - startTime,\n        timestamp: new Date()\n      };\n    } catch (error) {\n      console.error('Error benchmarking volume calculations:', error);\n      throw error;\n    }\n  }\n\n  private static async benchmarkDirectQuery(tokenAddress: string) {\n    const startTime = Date.now();\n    \n    const result = await prisma.trade.findMany({\n      where: {\n        tokenAddress: tokenAddress.toLowerCase(),\n        timestamp: {\n          gte: new Date(Date.now() - 24 * 60 * 60 * 1000)\n        }\n      },\n      select: {\n        type: true,\n        amountIn: true,\n        amountOut: true\n      }\n    });\n\n    const volume = result.reduce((sum, trade) => {\n      const ethAmount = trade.type === 'BUY' ? trade.amountIn : trade.amountOut;\n      return sum + BigInt(ethAmount);\n    }, 0n);\n\n    return {\n      method: 'direct_query',\n      duration: Date.now() - startTime,\n      volume: volume.toString(),\n      recordCount: result.length\n    };\n  }\n\n  private static async benchmarkAggregatedQuery(tokenAddress: string) {\n    const startTime = Date.now();\n    \n    const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);\n    \n    const result = await prisma.$queryRaw<Array<{ volume: string }>>`\n      SELECT \n        COALESCE(SUM(\n          CASE \n            WHEN type = 'BUY' THEN \"amountIn\"::numeric \n            ELSE \"amountOut\"::numeric \n          END\n        ), 0) as volume\n      FROM \"trades\" \n      WHERE \"tokenAddress\" = ${tokenAddress.toLowerCase()}\n        AND \"timestamp\" >= ${oneDayAgo}\n    `;\n\n    return {\n      method: 'aggregated_query',\n      duration: Date.now() - startTime,\n      volume: result[0]?.volume || '0'\n    };\n  }\n\n  private static async benchmarkMaterializedView(tokenAddress: string) {\n    const startTime = Date.now();\n    \n    try {\n      const result = await prisma.$queryRaw<Array<{ volume24h: string }>>`\n        SELECT \"volume24h\"\n        FROM \"token_stats_mv\"\n        WHERE \"tokenAddress\" = ${tokenAddress.toLowerCase()}\n      `;\n\n      return {\n        method: 'materialized_view',\n        duration: Date.now() - startTime,\n        volume: result[0]?.volume24h || '0'\n      };\n    } catch {\n      return {\n        method: 'materialized_view',\n        duration: Date.now() - startTime,\n        volume: '0',\n        error: 'Materialized view not available'\n      };\n    }\n  }\n\n  /**\n   * Monitor cache performance\n   */\n  static getCacheMetrics() {\n    // This would integrate with your cache monitoring\n    // For now, return basic info\n    return {\n      volumeCache: {\n        // Add cache-specific metrics here\n        enabled: true,\n        ttl: 5 * 60 * 1000, // 5 minutes\n        timestamp: new Date()\n      }\n    };\n  }\n\n  /**\n   * Health check for trading system\n   */\n  static async healthCheck() {\n    try {\n      const checks = await Promise.allSettled([\n        // Database connectivity\n        prisma.$queryRaw`SELECT 1`,\n        \n        // Recent trade activity\n        prisma.trade.count({\n          where: {\n            timestamp: {\n              gte: new Date(Date.now() - 60 * 60 * 1000) // Last hour\n            }\n          }\n        }),\n        \n        // Token count\n        prisma.token.count(),\n        \n        // Active holders\n        prisma.holder.count({\n          where: {\n            balance: { gt: '0' }\n          }\n        })\n      ]);\n\n      const [dbCheck, tradeCount, tokenCount, holderCount] = checks;\n\n      return {\n        status: checks.every(check => check.status === 'fulfilled') ? 'healthy' : 'degraded',\n        database: dbCheck.status === 'fulfilled' ? 'connected' : 'error',\n        recentTrades: tradeCount.status === 'fulfilled' ? tradeCount.value : 0,\n        totalTokens: tokenCount.status === 'fulfilled' ? tokenCount.value : 0,\n        activeHolders: holderCount.status === 'fulfilled' ? holderCount.value : 0,\n        timestamp: new Date(),\n        errors: checks\n          .filter(check => check.status === 'rejected')\n          .map(check => (check as PromiseRejectedResult).reason)\n      };\n    } catch (error) {\n      return {\n        status: 'error',\n        database: 'error',\n        error: error.message,\n        timestamp: new Date()\n      };\n    }\n  }\n\n  /**\n   * Get volume trends over time\n   */\n  static async getVolumeTrends(hours: number = 24) {\n    const hoursAgo = new Date(Date.now() - hours * 60 * 60 * 1000);\n    \n    const trends = await prisma.$queryRaw<Array<{\n      hour: Date;\n      volume: string;\n      trade_count: bigint;\n      unique_tokens: bigint;\n      unique_traders: bigint;\n    }>>`\n      SELECT \n        DATE_TRUNC('hour', \"timestamp\") as hour,\n        SUM(\n          CASE \n            WHEN \"type\" = 'BUY' THEN \"amountIn\"::numeric \n            ELSE \"amountOut\"::numeric \n          END\n        ) as volume,\n        COUNT(*) as trade_count,\n        COUNT(DISTINCT \"tokenAddress\") as unique_tokens,\n        COUNT(DISTINCT \"trader\") as unique_traders\n      FROM \"trades\" \n      WHERE \"timestamp\" >= ${hoursAgo}\n      GROUP BY DATE_TRUNC('hour', \"timestamp\")\n      ORDER BY hour ASC\n    `;\n\n    return trends;\n  }\n\n  /**\n   * Alert on performance degradation\n   */\n  static async checkPerformanceAlerts() {\n    const alerts = [];\n\n    try {\n      // Check for slow queries\n      const slowQueries = await prisma.$queryRaw<Array<{\n        query: string;\n        mean_time: number;\n      }>>`\n        SELECT query, mean_time\n        FROM pg_stat_statements \n        WHERE mean_time > 1000\n        ORDER BY mean_time DESC\n        LIMIT 5\n      `;\n\n      if (slowQueries.length > 0) {\n        alerts.push({\n          type: 'slow_queries',\n          severity: 'warning',\n          message: `Found ${slowQueries.length} slow queries`,\n          details: slowQueries\n        });\n      }\n    } catch {\n      // pg_stat_statements not available\n    }\n\n    // Check for large table sizes\n    try {\n      const largeTables = await prisma.$queryRaw<Array<{\n        table_name: string;\n        size_mb: number;\n      }>>`\n        SELECT \n          tablename as table_name,\n          pg_total_relation_size(tablename::regclass) / 1024 / 1024 as size_mb\n        FROM pg_tables \n        WHERE schemaname = 'public'\n          AND pg_total_relation_size(tablename::regclass) > 1073741824 -- 1GB\n      `;\n\n      if (largeTables.length > 0) {\n        alerts.push({\n          type: 'large_tables',\n          severity: 'info',\n          message: `Found ${largeTables.length} tables larger than 1GB`,\n          details: largeTables\n        });\n      }\n    } catch (error) {\n      alerts.push({\n        type: 'monitoring_error',\n        severity: 'error',\n        message: 'Error checking table sizes',\n        details: error.message\n      });\n    }\n\n    return {\n      alerts,\n      timestamp: new Date(),\n      alertCount: alerts.length\n    };\n  }\n}